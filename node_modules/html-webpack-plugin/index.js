// @ts-check
"use strict";

const promisify = require("util").promisify;

const vm = require("vm");
const fs = require("fs");
const _uniq = require("lodash/uniq");
const path = require("path");
const { CachedChildCompilation } = require("./lib/cached-child-compiler");

const {
  createHtmlTagObject,
  htmlTagObjectToString,
  HtmlTagArray,
} = require("./lib/html-tags");
const prettyError = require("./lib/errors.js");
const chunkSorter = require("./lib/chunksorter.js");
const { AsyncSeriesWaterfallHook } = require("tapable");

/** @typedef {import("./typings").HtmlTagObject} HtmlTagObject */
/** @typedef {import("./typings").Options} HtmlWebpackOptions */
/** @typedef {import("./typings").ProcessedOptions} ProcessedHtmlWebpackOptions */
/** @typedef {import("./typings").TemplateParameter} TemplateParameter */
/** @typedef {import("webpack").Compiler} Compiler */
/** @typedef {import("webpack").Compilation} Compilation */
/** @typedef {Required<Compilation["outputOptions"]["publicPath"]>} PublicPath */
/** @typedef {ReturnType<Compiler["getInfrastructureLogger"]>} Logger */
/** @typedef {Compilation["entrypoints"] extends Map<string, infer I> ? I : never} Entrypoint */
/** @typedef {Array<{ name: string, source: import('webpack').sources.Source, info?: import('webpack').AssetInfo }>} PreviousEmittedAssets */
/** @typedef {{ publicPath: string, js: Array<string>, css: Array<string>, manifest?: string, favicon?: string }} AssetsInformationByGroups */
/** @typedef {import("./typings").Hooks} HtmlWebpackPluginHooks */
/**
 * @type {WeakMap<Compilation, HtmlWebpackPluginHooks>}}
 */
const compilationHooksMap = new WeakMap();

class HtmlWebpackPlugin {
  // The following is the API definition for all available hooks
  // For the TypeScript definition, see the Hooks type in typings.d.ts
  /**
   beforeAssetTagGeneration:
   AsyncSeriesWaterfallHook<{
      assets: {
        publicPath: string,
        js: Array<string>,
        css: Array<string>,
        favicon?: string | undefined,
        manifest?: string | undefined
      },
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>,
   alterAssetTags:
   AsyncSeriesWaterfallHook<{
      assetTags: {
        scripts: Array<HtmlTagObject>,
        styles: Array<HtmlTagObject>,
        meta: Array<HtmlTagObject>,
      },
      publicPath: string,
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>,
   alterAssetTagGroups:
   AsyncSeriesWaterfallHook<{
      headTags: Array<HtmlTagObject | HtmlTagObject>,
      bodyTags: Array<HtmlTagObject | HtmlTagObject>,
      publicPath: string,
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>,
   afterTemplateExecution:
   AsyncSeriesWaterfallHook<{
      html: string,
      headTags: Array<HtmlTagObject | HtmlTagObject>,
      bodyTags: Array<HtmlTagObject | HtmlTagObject>,
      outputName: string,
      plugin: HtmlWebpackPlugin,
    }>,
   beforeEmit:
   AsyncSeriesWaterfallHook<{
      html: string,
      outputName: string,
      plugin: HtmlWebpackPlugin,
    }>,
   afterEmit:
   AsyncSeriesWaterfallHook<{
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>
   */

  /**
   * Returns all public hooks of the html webpack plugin for the given compilation
   *
   * @param {Compilation} compilation
   * @returns {HtmlWebpackPluginHooks}
   */
  static getCompilationHooks(compilation) {
    let hooks = compilationHooksMap.get(compilation);

    if (!hooks) {
      hooks = {
        beforeAssetTagGeneration: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        alterAssetTags: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        alterAssetTagGroups: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        afterTemplateExecution: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        beforeEmit: new AsyncSeriesWaterfallHook(["pluginArgs"]),
        afterEmit: new AsyncSeriesWaterfallHook(["pluginArgs"]),
      };
      compilationHooksMap.set(compilation, hooks);
    }

    return hooks;
  }

  /**
   * @param {HtmlWebpackOptions} [options]
   */
  constructor(options) {
    /** @type {HtmlWebpackOptions} */
    // TODO remove me in the next major release
    this.userOptions = options || {};
    this.version = HtmlWebpackPlugin.version;

    // Default options
    /** @type {ProcessedHtmlWebpackOptions} */
    const defaultOptions = {
      template: "auto",
      templateContent: false,
      templateParameters: templateParametersGenerator,
      filename: "index.html",
      publicPath:
        this.userOptions.publicPath === undefined
          ? "auto"
          : this.userOptions.publicPath,
      hash: false,
      inject: this.userOptions.scriptLoading === "blocking" ? "body" : "head",
      scriptLoading: "defer",
      compile: true,
      favicon: false,
      minify: "auto",
      cache: true,
      showErrors: true,
      chunks: "all",
      excludeChunks: [],
      chunksSortMode: "auto",
      meta: {},
      base: false,
      title: "Webpack App",
      xhtml: false,
    };

    /** @type {ProcessedHtmlWebpackOptions} */
    this.options = Object.assign(defaultOptions, this.userOptions);
  }

  /**
   *
   * @param {Compiler} compiler
   * @returns {void}
   */
  apply(compiler) {
    this.logger = compiler.getInfrastructureLogger("HtmlWebpackPlugin");

    const options = this.options;

    options.template = this.getTemplatePath(
      this.options.template,
      compiler.context,
    );

    // Assert correct option spelling
    if (
      options.scriptLoading !== "defer" &&
      options.scriptLoading !== "blocking" &&
      options.scriptLoading !== "module" &&
      options.scriptLoading !== "systemjs-module"
    ) {
      /** @type {Logger} */
      (this.logger).error(
        'The "scriptLoading" option need to be set to "defer", "blocking" or "module" or "systemjs-module"',
      );
    }

    if (
      options.inject !== true &&
      options.inject !== false &&
      options.inject !== "head" &&
      options.inject !== "body"
    ) {
      /** @type {Logger} */
      (this.logger).error(
        'The `inject` option needs to be set to true, false, "head" or "body',
      );
    }

    if (
      this.options.templateParameters !== false &&
      typeof this.options.templateParameters !== "function" &&
      typeof this.options.templateParameters !== "object"
    ) {
      /** @type {Logger} */
      (this.logger).error(
        "The `templateParameters` has to be either a function or an object or false",
      );
    }

    // Default metaOptions if no template is provided
    if (
      !this.userOptions.template &&
      options.templateContent === false &&
      options.meta
    ) {
      options.meta = Object.assign(
        {},
        options.meta,
        {
          // TODO remove in the next major release
          // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag
          viewport: "width=device-width, initial-scale=1",
        },
        this.userOptions.meta,
      );
    }

    // entryName to fileName conversion function
    const userOptionFilename =
      this.userOptions.filename || this.options.filename;
    const filenameFunction =
      typeof userOptionFilename === "function"
        ? userOptionFilename
        : // Replace '[name]' with entry name
          (entryName) => userOptionFilename.replace(/\[name\]/g, entryName);

    /** output filenames for the given entry names */
    const entryNames = Object.keys(compiler.options.entry);
    const outputFileNames = new Set(
      (entryNames.length ? entryNames : ["main"]).map(filenameFunction),
    );

    // Hook all options into the webpack compiler
    outputFileNames.forEach((outputFileName) => {
      // Instance variables to keep caching information for multiple builds
      const assetJson = { value: undefined };
      /**
       * store the previous generated asset to emit them even if the content did not change
       * to support watch mode for third party plugins like the clean-webpack-plugin or the compression plugin
       * @type {PreviousEmittedAssets}
       */
      const previousEmittedAssets = [];

      // Inject child compiler plugin
      const childCompilerPlugin = new CachedChildCompilation(compiler);

      if (!this.options.templateContent) {
        childCompilerPlugin.addEntry(this.options.template);
      }

      // convert absolute filename into relative so that webpack can
      // generate it at correct location
      let filename = outputFileName;

      if (path.resolve(filename) === path.normalize(filename)) {
        const outputPath =
          /** @type {string} - Once initialized the path is always a string */ (
            compiler.options.output.path
          );

        filename = path.relative(outputPath, filename);
      }

      compiler.hooks.thisCompilation.tap(
        "HtmlWebpackPlugin",
        /**
         * Hook into the webpack compilation
         * @param {Compilation} compilation
         */
        (compilation) => {
          compilation.hooks.processAssets.tapAsync(
            {
              name: "HtmlWebpackPlugin",
              stage:
                /**
                 * Generate the html after minification and dev tooling is done
                 */
                compiler.webpack.Compilation
                  .PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE,
            },
            /**
             * Hook into the process assets hook
             * @param {any} _
             * @param {(err?: Error) => void} callback
             */
            (_, callback) => {
              this.generateHTML(
                compiler,
                compilation,
                filename,
                childCompilerPlugin,
                previousEmittedAssets,
                assetJson,
                callback,
              );
            },
          );
        },
      );
    });
  }

  /**
   * Helper to return the absolute template path with a fallback loader
   *
   * @private
   * @param {string} template The path to the template e.g. './index.html'
   * @param {string} context The webpack base resolution path for relative paths e.g. process.cwd()
   */
  getTemplatePath(template, context) {
    if (template === "auto") {
      template = path.resolve(context, "src/index.ejs");
      if (!fs.existsSync(template)) {
        template = path.join(__dirname, "default_index.ejs");
      }
    }

    // If the template doesn't use a loader use the lodash template loader
    if (template.indexOf("!") === -1) {
      template =
        require.resolve("./lib/loader.js") +
        "!" +
        path.resolve(context, template);
    }

    // Resolve template path
    return template.replace(
      /([!])([^/\\][^!?]+|[^/\\!?])($|